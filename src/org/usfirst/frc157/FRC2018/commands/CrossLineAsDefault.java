// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc157.FRC2018.commands;

import org.usfirst.frc157.FRC2018.PID;
import org.usfirst.frc157.FRC2018.Robot;
import org.usfirst.frc157.FRC2018.SlewRate;
import org.usfirst.frc157.FRC2018.commands.CenterSwitchAuton.autonState;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
// import org.usfirst.frc157.FRC2018.Robot;

/**
 *
 */
public class CrossLineAsDefault extends Command
{
    // cross the line

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    private PID drivePID;
    private PID gyroDrivePID;
    private double drivePower = 0;
    private double leftPower = 0;
    private double rightPower = 0;
    private double initAngle = 0;
    private int repsAtTarget = 0;
    private double angle = 0;
    private double encoder;
    private double target;
    private boolean autonFinished = false;
    private SlewRate slewRate;
    private boolean slewCut = false;
    private int printDataCnt = 0;
    private boolean firstIteration;
    private double startTime;
    private int left;

    public CrossLineAsDefault(boolean left)
    {
        requires(Robot.drive);
        drivePID = new PID(0.028, 0.1, 0.000005, 10, 10, 999999, 9999999);
        gyroDrivePID = new PID(0.01, 0, 0.000001, 999999, 99999, 999999, 9999999);
        System.out.println("CrosslineWithSensors: built");
        slewRate = new SlewRate(0.5);
        firstIteration = false;
        this.left = (left) ? 1 : -1;
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize()
    {
        reset();
        System.out.println("CrosslineWithSensors: initialize()");
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute()
    {
        String gameData = DriverStation.getInstance().getGameSpecificMessage().toUpperCase();
        if (gameData == null || gameData.equals(""))
        {
            gameData = "ZZZ";
        }
        if (firstIteration)
        {
            startTime = Timer.getFPGATimestamp();
            reset();
            firstIteration = false;
        }
        if ((left == -1 && gameData.charAt(0) == 'L') || (left == 1) && gameData.charAt(0) == 'R')
        {
            // double power = slewRate.rateCalculate(0.8);
            encoder = (Robot.drive.getRightEncoder() + Robot.drive.getLeftEncoder()) / 2.0;
            target = 12.0 * 12.0; // convert feet to inches
            drivePower = drivePID.pidCalculate(target, encoder);
            if (!slewCut)
            {
                drivePower = slewRate.rateCalculate(drivePower);
            }
            if (Math.abs(drivePower) >= 0.9)
            {
                slewCut = true;
            }

            if (printDataCnt == 10)
            {
                System.out.println("CrosslineWithSensors: execute()");
                System.out.println("Power: " + drivePower);
                System.out.println("Right Encoder: " + Robot.drive.getRightEncoder() + "\nLeft Encoder: " + Robot.drive.getLeftEncoder());
                System.out.println("\nEncoder: " + encoder + "\nGyro: " + Robot.drive.getAngle() + "\nAngle: " + angle);
                printDataCnt = 0;
            }
            else
            {
                printDataCnt++;
            }
            leftPower = drivePower - gyroDrivePID.pidCalculate(initAngle, Robot.drive.getAngle());
            leftPower = ((leftPower > 0) ? 1 : -1) * Math.min(1, Math.abs(leftPower));

            rightPower = drivePower + gyroDrivePID.pidCalculate(initAngle, Robot.drive.getAngle());
            rightPower = ((rightPower > 0) ? 1 : -1) * Math.min(1, Math.abs(rightPower));

            Robot.drive.AutoDrive(leftPower, rightPower);
            if (Math.abs(encoder - target) < 5.0)
            {
                repsAtTarget++;
                if (repsAtTarget >= 2)
                {
                    autonFinished = true;

                    System.out.println("CrossLineWithSensors:execute():broken 1");
                }
            }
            else
            {
                repsAtTarget = 0;
            }
        }
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished()
    {
        return autonFinished;
    }

    // Called once after isFinished returns true
    @Override
    protected void end()
    {
        Robot.drive.AutoDrive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted()
    {
        Robot.drive.AutoDrive(0, 0);
    }

    public void reset()
    {
        Robot.drive.AutoDrive(0, 0);
        Robot.drive.resetLeftEncoder();
        Robot.drive.resetRightEncoder();
        repsAtTarget = 0;
        initAngle = Robot.drive.getAngle();
        slewRate = new SlewRate(0.5);
        slewCut = false;
    }
}
